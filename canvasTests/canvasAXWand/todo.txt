//redo this cvs.els (dynamically give ctx AND good type/id support)



let at=0
for (let i=91;i<180;i++) {
    setTimeout(()=>{
        source.initDeg = i
        source.reflect(2, true)
    },at+=50)
}


let c=source.getReflectPos(180)
if (c) cvs.els.push(new Reflect(cvs.ctx, source, c.x, c.y, 5, "red"))


// (++) | (-+)
// ==== + ====
// (+-) | (--)









getReflectPos(degrees) {
    let degDir = (degrees??this._initDeg)%360, deg = 360-degDir, dir = [!(degDir>=270||degDir<90)*2-1, (degDir>=0&&degDir<180)*2-1], a = Math.tan(toRad(deg)), b = -(a*this._x-this._y)
        console.log("DIR", degDir, dir)
    let v = obstacles.map(o=>{
        let [oa, ob, oFnY] = o.abfn, x, y

        if (!oa) x = (ob-this._y)/a + this._x // horizontal obs
        else if (!isFinite(oa)) y = a*(x=o.p1[0])+b
        else x = (((this._y-ob) - a*this._x)/oa) / (1 - a/oa) // inclined obs
        y ??= oFnY(x)
        let difX = this._x-x, difY = this._y-y, dif = Math.sqrt(difX**2+difY**2), ds = Math.sign(difX+difY)||1, cond = o.isPartOf([x,y]) && // line length
        ((dir[0] == Math.sign(difX)||ds) || !(degDir%90)) && // single dir horizontal
        ((dir[1] == Math.sign(difY)||ds) || !(degDir%90)) && // single dir vertical
        x >= 0 && x <= cvs.width && // inside cavas width
        y >= 0 && y <= cvs.height // inside cavas width

        console.log(x, y, difX, difY, "DIF", difX+difY, " |OR :", Math.sqrt(difX**2 + difY**2), "cadX",Math.sign(difX)||ds, "cadY",Math.sign(difY)||degrees?ds:1, ds)
        
        return {x, y, cadX:Math.sign(difX)||ds, cadY:Math.sign(difY)||ds, dif:dif, o:o}
    }).filter(r=>
        r
    ).toSorted((a,b)=>Math.abs(a.dif)-Math.abs(b.dif))
    console.log(v)
    return v[0]
}